# 红黑树、平衡二叉树

## 1.红黑树

[博客地址](https://blog.csdn.net/u014454538/article/details/120120216)

[红黑树和四阶B树的关联](https://blog.csdn.net/cy973071263/article/details/122543826)



### 1. 引入

二叉查找树->平衡二叉树->红黑树



#### 1.1 定义

1. 结点不是黑色就是红色
2. 根节点为黑色
3. 叶子结点为黑色（null或者nil)
4. 一个结点为红色，则其两个子结点必须是黑色的(根道叶子结点的所有路径，不可能存在两个连续的红色结点)
5. 每个结点到叶子结点的所路径，都包含相同数目的黑色结点 （相同的黑色高度）

#### 1.2 应用

1. TreeMap, TreeSet
2. jdk1.8+的hashMap, 如果链的长度超过了8自动转化为红黑树
3. LinuxCFS的进程调度算法
4. 多路复用技术中Epoll的核心结构红黑树 + 双向链表

### 2. 红黑树的操作

#### 2.1 红黑树的旋转

**2.1.1 左旋**

1. 空出出右儿子的左子树
2. 空出结点P的父节点
3. 结点P和右儿子成功会师，成为右儿子的左节点

![image-20220713213017645](D:\blgs\source\imgs\image-20220713213017645.png)

**2.1.2 右旋**

![image-20220713213114899](D:\blgs\source\imgs\image-20220713213114899.png)

#### 2.2 红黑树的插入

**2.2.1 插入规则**

1. 插入红节点， 因为插入黑节点会影响树的高度。树的高度是由黑色结点决定的。
2. 循环条件x != null && x != root && x.parent.color = RED。也就是如果父亲结点时红结点才需要调整
3. 完成调整后，**需要将根结点设置成为黑色**。 

**2.2.2 父亲作为祖父的左儿子**

情况一：叔是红.

1. 父辈改黑（叔叔和父亲），祖结点改红
2. 从祖先递归调整。

![image-20220713213756441](D:\blgs\source\imgs\image-20220713213756441.png)

情况二：叔是黑，自己是左儿子

1. 父亲改黑，爷爷改红。
2. 进行右旋

![image-20220713213804812](D:\blgs\source\imgs\image-20220713213804812.png)

情况三：叔是黑，自己是右儿子

1. 首先p右旋
2. 转换成情况2

![image-20220713213814860](D:\blgs\source\imgs\image-20220713213814860.png)

**2.2.3 父亲作为祖父的右儿子**

上面的镜像操作

![image-20220713213831158](D:\blgs\source\imgs\image-20220713213831158.png)

![image-20220713213837733](D:\blgs\source\imgs\image-20220713213837733.png)



![image-20220713213847708](D:\blgs\source\imgs\image-20220713213847708.png)





**2.2.4代码**

```java
public void fixAfterInsert(RedBlackTreeNode x) {
    // 新插入的节点，默认为红色
    x.color = RED;

    // p不为null、不是整棵树的根节点、父亲为红色，需要调整
    while (x != null && this.root != x && x.parent.color == RED) {
        // 父亲是祖父的左儿子
        if (parentOf(x) == parentOf(parentOf(x)).left) {
            // 父亲和叔叔都是红色
            RedBlackTreeNode uncle = parentOf(parentOf(x)).right;
            if (uncle.color == RED) {
                // 父亲和叔叔都变成黑色
                parentOf(x).color = BLACK;
                uncle.color = BLACK;
                // 祖父变成红色，继续从祖父开始进行调整
                parentOf(parentOf(x)).color = RED;
                x = parentOf(parentOf(x));
            } else { // 叔叔为黑色
                // 自己是父亲的右儿子，需要对父亲左旋
                if (x == parentOf(x).right) {
                    x = parentOf(x);
                    leftRotate(x);
                }
                // 自己是父亲的左儿子，变色后右旋，保持黑色高度
                parentOf(x).color = BLACK;
                parentOf(parentOf(x)).color = RED;
                rightRotate(parentOf(parentOf(x)));
            }
        } else { //父亲是祖父的右儿子
            RedBlackTreeNode uncle = parentOf(parentOf(x)).left;
            // 父亲和叔叔都是红色
            if (uncle.color == RED) {
                // 叔叔和父亲变成黑色
                parentOf(x).color = BLACK;
                uncle.color = BLACK;
                // 祖父变为红色，从祖父开始继续调整
                parentOf(parentOf(x)).color = RED;
                x = parentOf(parentOf(x));
            } else {
                // 自己是父亲的左儿子，以父亲为中心右旋
                if (parentOf(x).left == x) {
                    x = parentOf(x);
                    rightRotate(x);
                }
                // 自己是父亲的右儿子，变色后左旋，保持黑色高度
                parentOf(x).color = BLACK;
                parentOf(parentOf(x)).color = RED;
                leftRotate(parentOf(parentOf(x)));
            }
        }
    }

    // 最后将根节点置为黑色，以满足红黑规则1，又不会破坏规则5
    this.root.color = BLACK;
}

private static RedBlackTreeNode parentOf(RedBlackTreeNode p) {
    return (p == null ? null : p.parent);
}

```



#### 2.3 红黑树的删除

**2.3.1 删除规则**



1. 循环条件 x != root && x.color == BLACK。也就是说如果是黑色的才需要调整
2. 完成循环后，将x设置成为黑色。
3. 通过结点替换，实现删除，把删除的结点下沉到叶子结点，之后进行删除，最后进行调整。
4. 假设替换结点为x,需要在x替换被删除结点后，从x开始进行调整。

**B树中，最后真正被删除的元素都在叶子节点中。所以在红黑树中，被删除的节点一定也在最后一层。**

上面的话也证明了需要下沉到最后一层进行操作。

**2.3.2自己为父亲的左儿子**

情况一：兄弟为红色

1. 兄弟变黑，父节点变红，左子树高度降低。
2. 父节点进行左旋，把兄弟提上来。
3. 此时变成了情况2、3、4其中的一种。因为右兄弟已经变黑了。



![image-20220713221350776](D:\blgs\source\imgs\image-20220713221350776.png)

情况二：兄弟为黑色，左右侄子也为黑色

将兄弟变成红色，x指向父节点。继续调整。（删除之后高度减少了1,右边需要同时减少）。如果父亲为红，直接break，然后改成黑。如果父亲为黑，这棵树的黑色结点高度减少了1，需要进行调整。



![image-20220713221425450](D:\blgs\source\imgs\image-20220713221425450.png)

情况三：兄弟为黑色，右侄子为黑色，左侄子为红色‘

1. 自己和兄弟均为黑色，父亲不确定。
2. 把兄弟改成红，左侄子改成黑。
3. 兄弟结点右旋。
4. 此时的x满足了情况4，进行调整

![image-20220713221819482](D:\blgs\source\imgs\image-20220713221819482.png)

情况四：兄弟为黑色，右侄子为红色

1. 兄弟和父结点修改成一致，父亲改成黑色。
2. 父亲结点左旋
3. x指向根节点，调整结束。

可以看到此时左边的高度相比于之前已经多了一个父节点。右边的高度不变。

![image-20220713221859621](D:\blgs\source\imgs\image-20220713221859621.png)

**2.3.3 是父亲的右儿子**

**2.3.4 代码**

```java
public void fixAfterDeletion(RedBlackTreeNode x) {
    // x不是根节点且颜色为黑色，开始循环调整
    while (x != root && x.color == BLACK) {
        // x是父亲的左儿子
        if (x == parentOf(x).left) {
            RedBlackTreeNode brother = parentOf(x).right;
            // 兄弟为红色
            if (brother.color == RED) {
                // 兄弟变成黑色，父节点变成红色
                brother.color = BLACK;
                parentOf(x).color = RED;
                // 父节点左旋，恢复左子树的黑色高度
                leftRotate(parentOf(x));
                // 更新兄弟
                brother = parentOf(x).right;
            }

            // 兄弟为黑色，左右侄子为黑色
            if (brother.left.color == BLACK && brother.right.color == BLACK) {
                // 兄弟变成红色
                brother.color = RED;
                // 从父节点开始继续调整
                x = parentOf(x);
            } else {
                // 右侄子为黑色（左侄子为红色）
                if (brother.right.color == BLACK) {
                    // 左侄子变为黑色，兄弟变成红色
                    brother.left.color = BLACK;
                    brother.color = RED;
                    // 兄弟右旋，恢复右子树黑色高度
                    rightRotate(brother);
                    // 左侄子成为新的兄弟
                    brother = parentOf(x).right;
                }
                // 右侄子为红色，兄弟变成父节点颜色
                brother.color = parentOf(x).color;
                // 父节点和右侄子变成黑色
                parentOf(x).color = BLACK;
                brother.right.color = BLACK;
                // 父节点左旋
                leftRotate(parentOf(x));
                // x指向根节点
                x = root;
            }
        } else {
            RedBlackTreeNode brother = parentOf(x).left;
            // 兄弟为红色
            if (brother.color == RED) {
                // 兄弟变黑色，父亲变红色
                brother.color = BLACK;
                parentOf(x).color = RED;
                // 父亲右旋，恢复红黑色高度
                rightRotate(parentOf(x));
                // 更新兄弟为右侄子
                brother = parentOf(x).left;
            }

            // 兄弟的左右儿子为黑色
            if (brother.left.color == BLACK && brother.right.color == BLACK) {
                // 兄弟变为红色
                brother.color = RED;
                // x指向父节点，继续进行调整
                x = parentOf(x);
            } else {
                // 左侄子为黑色(右侄子为红色)
                if (brother.left.color == BLACK) {
                    // 右侄子变黑色，兄弟变红色
                    brother.right.color = BLACK;
                    brother.color = RED;
                    // 对兄弟左旋
                    leftRotate(brother);
                    // 右侄子成为新的兄弟
                    brother = parentOf(x).left;
                }

                // 左侄子为红色，兄弟改为父节点颜色
                brother.color = parentOf(x).color;
                // 父节点和左侄子变成黑色
                brother.left.color = BLACK;
                parentOf(x).color = BLACK;
                // 兄弟节点上提(右旋父节点)
                rightRotate(parentOf(x));
                // x指向根节点
                x = root;
            }

        }
    }
    // 更新x为黑色
    x.color = BLACK;
}

```





### 3. 总结





## 2. 平衡二叉树

## 3. B树

## 4. B+树

