# 并查集

| 题目                                                         | 知识点            | 难度 |
| ------------------------------------------------------------ | ----------------- | ---- |
| [6159. 删除操作后的最大子段和](https://leetcode.cn/problems/maximum-segment-sum-after-removals/solution/si-wei-bingcha-by-man-qian-shu-xiao-ming-q1c4/) | 并查集 + 反向思考 |      |
| [827.最大人工岛屿](https://leetcode.cn/problems/making-a-large-island/) | 并查集 + 枚举     | 困难 |
| [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/) | 并查集模板        | 中等 |
|                                                              |                   |      |
|                                                              |                   |      |



# 代码模板



```cpp

 vector<int>parent;
    vector<int>rank;
    void inite(int n){
        for(int i = 0; i < n; i++){
            parent.push_back(i);
            rank.push_back(1);
        }
    }
    int find(int x){
        if(x == parent[x]) return x;
        return find(parent[x]);
    }
    void unite(int x, int y){
        x = find(x);
        y = find(y);
        if(x == y)return;
        if(rank[x] < rank[y])swap(x, y);
        parent[y] = x;
        rank[x] = max(rank[x], rank[y] + 1);
    }


```









