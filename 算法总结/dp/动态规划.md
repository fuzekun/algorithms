# 动态规划

> 小结

1. 背包问题：选择或者不选择
2. 最长上升子序列模型 ： 二分找到前一个最接近它的最大值或者最小值
3. 状态机模型：用一维度表示状态，画图寻找转化关系
4. 状态压缩dp：一维的状态可以用二进制表示，另一个在矩阵中式行或者列，在图论中式点的编号，教课问题中是：老师教课和id。
5. 数位dp: 如果最高位没有限制的话，那么可以直接得出答案，不用计算了。根据最高位进行划分。
6. 计数dp: 大多是选苹果问题的变形。





## 背包九讲

#### 1.01背包问题

```cpp
memset(dp, 0, sizeof 0);
for (int i = 0; i < n; i++) {
    for (int j = m; j >= w[i]; j--) {
        f[j] = max(f[j], f[j - w[i]] + v[i]);
    }
}
return f[m];
```



#### 2.完全背包问题

```cpp
memset(dp, 0, sizeof 0);
for (int i = 0; i < n; i++) {
    for (int j = w[i]; j <= m; j++) {
        f[j] = max(f[j], f[j - w[i]] + v[i]);
    }
}
return f[m];
```



#### 3.多重背包问题

1. 二进制优化版本

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N = 1005 , M=2005;
int dp[M],v[N*M],w[N*M];
int main()
{
    int n,m,k=0;
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        int vv,ww,s;
        cin>>vv>>ww>>s;
        for(int i=1;i<=s;i*=2)   //二进制优化
            v[k]=vv*i,w[k++]=ww*i,s-=i;
        if(s>0)
            v[k]=vv*s,w[k++]=ww*s;
    }
    for(int i=0;i<k;i++)        //01背包
        for(int j=m;j>=v[i];j--)
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    cout<<dp[m]<<endl;
    return 0;
}

```

2. 单调队列优化版本

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 20010;

int f[N], g[N], q[N];
int n, m;

int main() {
    cin >> n >> m;

    for (int i = 0; i < n; i++) {
        int v, s, w;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);

        for (int r = 0; r < v; r++) {
            int h = 0, t = -1;
            for (int j = r; j <= m; j += v) {

                /*
                    优先队列进行扩张
                    保证下标从head 到 tail 递增，下标对应的值递减, head对应的值使最大值
                    应该注意优先队列中存储的值是g[k]减去偏移量 (j - r) / v * w后的值
                */
                while (h <= t && g[q[t]] - (q[t] - r) / v * w <= g[j] - (j - r) / v * w) t--;
                q[++t] = j;
                /*
                    (j - q[h]) / v:表示拿了多少个
                    如果大于了s就需要进行移动。

                */
                while (h <= t && j - q[h] > v * s) h++;
                /*
                    (j - q[h]) / v:表示拿了多少个
                    q[h] : 表示最大值对应的下标
                    g[q[h]] : 表示g[r] g[r + v], g[r + 2 * v] ... g[r + s * v]中的最大值。
                    也可以表示g[r + v], g[r + 2 * v] ..     g[r + (s + 1) * v]中的最大值
                    ...
                */
                f[j] = max(f[j], (j - q[h]) / v * w + g[q[h]]);

            }
        }
    }
    cout << f[m] << endl;
    return 0;
}

```



#### 4.混合背包问题

```cpp
根据物品的类型进行计算即可
```



#### 5.二维费用的背包问题(有问题)

```cpp
#include<iostream>
using namespace std;
#define N 1005
int dp[N][N];
int main()
{
	int n,V,M,v,w,m;
	cin>>n>>V>>M;
	for(int i=0;i<n;i++)
	{
		cin>>v>>m>>w;
		for(int j=V;j>=v;j--)
		{
			for(int k=M;k>=m;k--)
				dp[j][k]=max(dp[j][k],dp[j-v][k-m]+w);
		}
	}
	cout<<dp[V][M]<<endl;
	return 0;
 } 
```



#### 6.分组背包问题

```cpp
memset(dp, 0, sizeof 0);
for (int i = 0; i < n; i++) {
    for (int j = m; j >= 0; j--) {
        for (int k = 0; k < nums[i]; k++) {
            f[j] = max(f[j], f[j - w[i][k]] + v[i][k]);
        }
    }
}
return f[m];
```



#### 7.有依赖的背包问题（有问题）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N =1005;
int e[N],w[N],v[N],ne[N],h[N],idx;
int dp[105][105];
int n,m;
void init()
{
    memset(h,-1,sizeof h);
    idx=0;
}
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void dfs(int x)
{
    for(int i=h[x];i!=-1;i=ne[i])
    {
        int son=e[i];
        dfs(son);
        for(int j=m;j>=0;j--)
        {
            for(int k=0;k<=j;k++)
                dp[x][j]=max(dp[x][j],dp[x][j-k]+dp[son][k]);
        }
    }
    for(int i=m;i>=0;i--)
        if(i>=v[x])
            dp[x][i]=dp[x][i-v[x]]+w[x];
        else          //注意，父节点不选的话，子节点一个都不能选
            dp[x][i]=0;
    
}
int main()
{
    init();
    int root;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int fa;
        scanf("%d%d%d",&v[i],&w[i],&fa);
        if(fa==-1)
            root=i;
        else
            add(fa,i);
    }
    dfs(root);
    cout<<dp[root][m]<<endl;
    return 0;
}


```



#### 8.背包问题求方案数

加上一个统计数组就行了。

```cpp
for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=v[i];j--)
        {
            if(dp[j-v[i]]+w[i]>dp[j])
            {
                dp[j]=dp[j-v[i]]+w[i];
                num[j]=num[j-v[i]];
            }
            else if(dp[j-v[i]]+w[i]==dp[j])
                num[j]=(num[j]+num[j-v[i]])%mod;
        }
    }
```



#### 9.求背包问题的具体方案

保证贪心枚举就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N =1005;
int dp[N][N],v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        scanf("%d%d",&v[i],&w[i]);
    for(int i=n;i>=1;i--)
    {
        for(int j=m;j>=0;j--)
        {
            dp[i][j]=dp[i+1][j];
            if(j>=v[i])
                dp[i][j]=max(dp[i][j],dp[i+1][j-v[i]]+w[i]);
        }
    }
    int val=m;
    for(int i=1;i<=n;i++)
    {
        if(val-v[i]>=0&&dp[i][val]==dp[i+1][val-v[i]]+w[i])
        {
            cout<<i<<" ";
            val-=v[i];
        }
    }
    return 0;
}

```



## 最长上升子序列





## 树形dp





### 题型1: 根据子和父划分



不能直接使用树的直径的dp。

- 没有考虑从父亲的来的，只考虑了自己的子树。



**[leetcode 求无根树的树高](https://leetcode-cn.com/problems/minimum-height-trees/)**



1. 无根树转换成有根树，使用fa来记录
2. 使用dp思想。
   - 如果已经知道父节点的深度。
   - 自己的高度 = max(父节点的除了自己这条链之外的深度 + 1, 自己的树高)
   - 根节点的高度 = max{子节点的高度}

如何求自己的树高？dfs

如何求父结点除了自己这条链的深度?

- 转化成有根树，过程中记录每个结点的最大值和次大值，以及最大值所在的子链，用于判断父节点去除本条链的树高。
- 父节点的深度 = max(父节点由父节点来的深度，父节点除去本条链的树高)。

总结来说

- dp(i, j)表示结点i，去除j这条链的深度。
- 根据深度的来源进行划分，一个是来自父节点的深度dp(fa[i], i)，一个是来自子节点去除本结点的高度height(i, j)。



注：这里的深度就是树高，这里树高指的是从叶子结点到本届点的深深度，链表示的是子树。

![image-20220406201416762](D:\blgs\source\imgs\image-20220406201416762.png)



```c++
class Solution {
public:

    // vector<int>father    
    // vector<int, unordered_map<int, int>>dp;    
    
    typedef pair<int, int>PR;
    typedef pair<int, PR>PRR;

    vector<PRR>d;      
    vector<vector<int>>G;
    int minh = INT_MAX;
    vector<int>ans;
    int getHeigth(int u, int fa) {
        int maxv = 0, scnd = 0, id = -1, n = G[u].size(); 
        for (int &v : G[u]) {
            if (v == fa) continue;
            int h = getHeigth(v, u) + 1;
            if (h > maxv) {
                scnd = maxv;
                maxv = h;
                id = v;
            } else if (h > scnd)
                scnd = h;
        }
        // printf("u = %d [%d, [%d, %d]]\n", u, id, maxv, scnd);
       
        d[u] = {id, {maxv, scnd}};
        return maxv;
    }

    void dfs(int u, int fa, int depth) {
        auto [num, val] = d[u];
        auto [maxv, scnd] = val;

        int h = max(maxv, depth);
        // printf("h[%d] = %d\n", u, h);
        if (minh > h) {
            minh = h;
            ans.clear();
            ans.push_back(u);
        } else if (minh == h) ans.push_back(u);

        for (int &v: G[u]) {
            if (v == fa) continue;
            int t = (num == v ? scnd : maxv);
            int nd = max(t, depth) + 1;
            
            // printf("height[%d][%d] = %d dp = %d\n", u, v, t, nd);
            dfs(v, u, nd); 
        }
    }
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        /*
            1. 无根树转换成有根树
            2. 遍历树，结点的高度是
            max{depth, height}
            其中depth是当前的深度,就是从0到它的深度
            height是当前树的高度，就是叶子节点到它的距离
        */
        G = vector<vector<int>>(n);
        d = vector<PRR>(n);
        for (vector<int>&edge : edges) {
            G[edge[0]].push_back(edge[1]);
            G[edge[1]].push_back(edge[0]);
        }

        getHeigth(0, -1);
        dfs(0, -1, 0);
        return ans;
    }
};
```

宫三的题解。应该注意到，**如果使用结构体不方便的话，不如直接使用数组**。题解和我想的是一样，但是这种感觉更容易写，不容易出错。

```java
class Solution {
    int N = 20010, M = N * 2, idx = 0;
    int[] he = new int[N], e = new int[M], ne = new int[M];
    int[] f1 = new int[N], f2 = new int[N], g = new int[N], p = new int[N];
    void add(int a, int b) {
        e[idx] = b;
        ne[idx] = he[a];
        he[a] = idx++;
    }
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        Arrays.fill(he, -1);
        for (int[] e : edges) {
            int a = e[0], b = e[1];
            add(a, b); add(b, a);
        }
        dfs1(0, -1);
        dfs2(0, -1);
        List<Integer> ans = new ArrayList<>();
        int min = n;
        for (int i = 0; i < n; i++) {
            int cur = Math.max(f1[i], g[i]);
            if (cur < min) {
                min = cur;
                ans.clear();
                ans.add(i);
            } else if (cur == min) {
                ans.add(i);
            }
        }
        return ans;
    }
    int dfs1(int u, int fa) {
        for (int i = he[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (j == fa) continue;
            int sub = dfs1(j, u) + 1;
            if (sub > f1[u]) {
                f2[u] = f1[u];
                f1[u] = sub;
                p[u] = j;
            } else if (sub > f2[u]) {
                f2[u] = sub;
            }
        }
        return f1[u];
    }
    void dfs2(int u, int fa) {
        for (int i = he[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (j == fa) continue;
            if (p[u] != j) g[j] = Math.max(g[j], f1[u] + 1);
            else g[j] = Math.max(g[j], f2[u] + 1);
            g[j] = Math.max(g[j], g[u] + 1);
            dfs2(j, u);
        }
    }
}
```



**[树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/)**

![image-20220406211243072](D:\blgs\source\imgs\image-20220406211243072.png)





同上一题一样，根据来自父亲的还是来自儿子的划分

- 首先dfs一次，自底向上，转化成无根树，求出每个结点树数目的个数，以及来自子节点的距离之和ans[u]。
- 之后再进行一次dfs，自顶向底，求出来自父节点的距离之和。公式为:
- $ans[v] = (ans[u] - ans[v] - cnt[v]) + (n - cnt[v]) = ans[u] + n - 2 * cnt[v];$   // 其中的n - cnt[v]，考虑到dis(u, u) = 0。

- 注意根节点没有来自父节点的值，这也是自顶向下的保证。



**[树的直径](https://leetcode-cn.com/problems/tree-diameter/)**



```java
建图：
    
    h[n];									//表示a的第条边的idx
    e[2 * n];								// 表示边idx指向的val， 类比于edge.val;
    nx[2 * n];								// idx指向的下一条边。	类比于edge.next;
 
void add(int a, int b) {
    e[++idx] = b;					// 创建新边
    nx[idx] = h[a];					// 新边插入头
    h[a] = idx;						// 头指向新边
}
```

```java

注意的输出点：
    1.输出每一个结点的fa
    2.输出每一个点对应的最大值和次大值。
    3.使用两个数组记录最大值和次大值比较好写。
```



```java
 
    int[] e, h, nx;
    int idx = 0;
    int []d1, d2;
    int ans = 0;
    private void add(int a, int b) {
        e[++idx] = b;
        nx[idx] = h[a];
        h[a] = idx;
    }
    private void dfs(int u, int fa) {
        for (int j = h[u]; j != -1; j = nx[j]) {
            int v = e[j];
            if (v == fa) continue;
            dfs(v, u);
            int d = d1[v] + 1;
            if (d > d1[u]) {
                d2[u] = d1[u];
                d1[u] = d;
            } else if (d > d2[u]) {
                d2[u] = d;
            }
        }
        // System.out.printf("u = %d , fa = %d ", u, fa);
        // System.out.printf("d1 = %d d2 = %d\n", d1[u], d2[u]);
        ans = Math.max(ans, d1[u] + d2[u]);
    }
    public int treeDiameter(int[][] edges) {
        int n = edges.length + 1;
        d1 = new int[n];
        d2 = new int[n];
        h = new int[n + 1];
        e = new int[2 * (n + 1)];
        nx = new int[2 * (n + 1)];
        Arrays.fill(h, -1);

        for (int[] edge: edges) {
            add(edge[0], edge[1]);
            add(edge[1], edge[0]);
        } 
        dfs(0, -1);
        return ans;
    }
```





### 题型2: 转化成拓扑排序的模型

**最小高度树**

由于有结论，长度/2上取整。所以最多有两个结点。每次从叶子结点(度为1的结点)删除，剩下个数 <= 2的时候就是答案。

可以证明:

- 最长路径的端点的度必然为1。x->p1->...pk->y;dist(x, y)是最大路径。如果x的度不为1，那么存在q使得dis(q, y) = dist(x,y)+1

- 删除所有的度为1的结点之后，p1, pk的度一定度为1。假设为p1还有一个q和他相连，q的度不为1，设为q', 那么dis(q',y) = dis(x,y)+1

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<Integer>();
        if (n == 1) {
            ans.add(0);
            return ans;
        }
        int[] degree = new int[n];
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<Integer>();
        }
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
            degree[edge[0]]++;
            degree[edge[1]]++;
        }
        Queue<Integer> queue = new ArrayDeque<Integer>();
        for (int i = 0; i < n; i++) {
            if (degree[i] == 1) {
                queue.offer(i);
            }
        }
        int remainNodes = n;
        while (remainNodes > 2) {
            int sz = queue.size();
            remainNodes -= sz;
            for (int i = 0; i < sz; i++) {
                int curr = queue.poll();
                for (int v : adj[curr]) {
                    degree[v]--;
                    if (degree[v] == 1) {
                        queue.offer(v);
                    }
                }
            }
        }
        while (!queue.isEmpty()) {
            ans.add(queue.poll());
        }
        return ans;
    }
}
```



**[相邻字符的不同路径长度](https://leetcode-cn.com/problems/longest-path-with-different-adjacent-characters/)**

![image-20220418174444813](D:\blgs\source\imgs\image-20220418174444813.png)

使用拓扑排序



- u[i]:表示以i为根的最大路径长度。u[pi]=max(t[i]+t[pi])
- t[i]: 表示以i为根的最大子树的长度。t[pi]=max(t[i]+1)
- 由于使用了拓扑排序，所以每次更新一层。路也有序的，t[pi]：表示除了本条路的树高。
- 更新顺序不能变，前提是在s[i] != s[pi]的情况下。

```c++
    int longestPath(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> d(n, 0);
        vector<int> t(n, 1);
        vector<int> u(n, 1);			// 初始化为1
        queue<int> q;
        for(int i=1; i<n; i++)
            d[parent[i]]++;
        for(int i=0; i<n; i++)
            if(!d[i]) q.emplace(i);
        while(!q.empty())
        {
            int i = q.front();q.pop();
            if(i == 0) break;
            int pi = parent[i];
            //u[pi] = max(u[pi], up[i]):
            if (s[i] != s[pi]) {
                u[pi] = max(u[pi], t[i] + t[pi]);
                t[pi] = max(t[pi], t[i] + 1);
            }
            if (--d[pi] == 0) {
                q.emplace(pi);
            }
        }
        return *max_element(u.begin(), u.end()); // 这一句不能少。
    }
```

```java
1. 只考虑了子树，没有考虑父结点过来的；
2. 最后一句不能少, 或者加上注释掉的话。或者记录一个全局的ans
       0			u[0] = 3
	  /	
  	 1  			u[1] = 4
 	/ \
   3   4
  / \  |
 5   6 7
```



**[树的直径]**

```c++
class Solution {
public:
/*


    1. 先把无根树化成有根树，0作为树根
    2. 使用拓扑排序，得到答案。
*/
    vector<int>parent;
    vector<vector<int>>G;
    void dfs(int u, int fa) {
        parent[u] = fa;
        // printf("u = %d, fa = %d\n", u, fa);
        for (int v: G[u]) {
            if (v == fa) continue;
            dfs(v, u);
        }
    }
    int treeDiameter(vector<vector<int>>& edges) {
        int n = edges.size() + 1;
        G = vector<vector<int>>(n);
        for (auto edge : edges) {
            G[edge[0]].push_back(edge[1]);
            G[edge[1]].push_back(edge[0]);
        }
        parent = vector<int>(n + 1);
        dfs(0, -1);

        vector<int> d(n, 0);
        vector<int> t(n, 1);
        vector<int> u(n, 1);
        queue<int> q;
        for(int i=1; i<n; i++)
            d[parent[i]]++;
        for(int i=0; i<n; i++)
            if(!d[i]) q.emplace(i);
        while(!q.empty())
        {
            int i = q.front();q.pop();
            // printf("%d\n", i);
            if(i == 0) break;
            int pi = parent[i];
            u[pi] = max(u[pi], t[i] + t[pi]);
            t[pi] = max(t[pi], t[i] + 1);
            if (--d[pi] == 0) {
                q.emplace(pi);
            }
        }
        return *max_element(u.begin(), u.end()) - 1;
    }
};
```







### 题型3 : 树的染色问题

1. 没有上司的舞会
2. 服务器
3. 相邻的树不能染同样颜色





