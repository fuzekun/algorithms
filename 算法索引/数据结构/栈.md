# 栈



## 题目



| 题目                                                         | 难度 |
| :----------------------------------------------------------- | :--: |
| [函数的独占时间](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) | 中等 |
| [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) | 困难 |
| [子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) | 困难 |
| [最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) | 困难 |
| [子数组最小乘积的最大值](https://leetcode.cn/problems/maximum-subarray-min-product/) | 困难 |
| [巫师的总力量和](https://leetcode.cn/problems/sum-of-total-strength-of-wizards/) | 困难 |
| [使数组按非递减顺序排列](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/) | 困难 |
| [基本计算器](https://leetcode.cn/problems/basic-calculator/) | 困难 |
| [基本计算器II](https://leetcode.cn/problems/basic-calculator-ii/) | 中等 |



## 经典栈应用 -- 计算器

1. 基本计算器

2. 基本计算器2
3. 基本计算器3
4. 基本计算器4



## 单调栈和单调队列

### 单调栈解决

1. 一维连续序列中，每一个值距离它最近的最大值或者最小值

### 单调队列解决

1. 一维连续序列中，当前窗口内的最大值。

### 思想：

单调队列：如果对于任意的下标i < j来说，如果h[i] < h[j] 那么i这个下标在j出去之前都不可能是最大值了，而j出去之后，i必然已经出去，所以i必然不可能是最大值了。你本来就比他菜，还没他努力，那么你就永远不可能超过他了。

单调栈：对于任意的下标i < j来说，如果h[i] < h[j]，那么每次向左找最大值的过程中，j就会把i给挡住，那么i就永远不会是最近的最大值。所以每次操作就需要把数据结构中小于h[j]的全部移除，只剩下大于h[j]的留下来。（找最小值相反，反向遍历则相同）。

栈：一个操作数把所有的都给消灭掉，直到不能消灭为止的数据结构。



出栈的时候，当前的i值就是大于栈顶元素的第一个右边位置，就是右边界。入栈的时候，栈顶元素就是小于i的左边第一个，就是左边界。



注意细节：

```c++
while(!s.empty() && nums[i] <= nums[s.top()]) {
    right[s.top()] = i;								// 找到的是小于等于s.top()的第一个右边的。注意包括等于的时候。
	s.pop();
} 
left[i] = s.empty() ? -1 : s.pop();					// 找到的是小于他的第一个，不包的时候。
```

细节2：

  两个边界：

1. 第一个是初始值边界，也就是找到小于还是小于的前一个。
   - 这个决定了是 r - l 还是 r - l + 1还是r - l - 1;

2. 第二个是小于等于和小于。

   -  这个一般是一个小于一个小于等于。计数的时候

   -  边界的时候：都小于。



### 经典题目

具体请看leetcode题单中的单调栈题单。



[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)



这个可以使用常数优化的条件是：

- 如果有多个相等的柱子。**最右侧的柱子是可以求出正确的右边界的**。当然是在找右侧小于等于的情况下。

[907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

- 常数优化
- 计算优化，初值以及计算都计算到边界。就可以使用(i - l) * (r - i)来进行计算组合数了。

[子数组范围和](https://leetcode-cn.com/problems/sum-of-subarray-ranges/)

- 上个题目的进阶版本
- 常数优化和计算优化



[最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

[1856. 子数组最小乘积的最大值](https://leetcode.cn/problems/maximum-subarray-min-product/)

[6077. 巫师的总力量和](https://leetcode.cn/problems/sum-of-total-strength-of-wizards/)

周赛的时候做的这个题目，想到了使用单调栈，也想到了前缀和的前缀和，但是不知道怎么求子区间的所有的和。

另外有几个细节：

1. 使用long long进行保存， 并且有减法，最后求的答案可能是负的。
2. 



总结不熟悉的知识点

- 使用前缀和时候的端点问题
- 连续子区间的几种求法。
- 单调栈的边界



```cpp
以r结尾的区间的包含i的和:
a[r] + a[r - 1] + ... + a[i],
a[r] + a[r - 2] + ... + a[i - 1],
...,
a[r] + a[r - 2] + ... + a[l];

以r - 1结尾的区间包含i的和:
a[r - 1] + a[r - 2] + ... + a[i],
a[r - 1] + a[r - 2] + ... + a[i - 1],
...,
a[r - 1] + a[r - 2] + ... + a[l],
....,

以i结尾的包含i的和:
a[i],
a[i] + a[i - 1],
...,
a[i] + a[i - 1] + a[i - 2]... + a[l];


写成前缀和的形式:
以r结尾的区间包含i的和
sum[r + 1] - sum[i],
sum[r + 1] - sum[i - 1],
...,
sum[r + 1] - sum[l];

以r - 1结尾的区间包含i的和:
sum[r] - sum[i],
sum[r] - sum[i - 1],
...,
sum[r] - sum[l];

...;

以i结尾的包含i的和:
sum[i + 1] - sum[i],
sum[i + 1] - sum[i - 1],
...,
sum[i + 1] - sum[l];



可以看到减号左边求和之后，是(i - l + 1) 个 {sum[r + 1], sum[r + 1], sum[i + 1]}
减号右边是: sum[l] + sum[l + 1] .. + sum[i]; 这样的和有(r - i + 1)个,
所以上面可以表示成(i - l + 1) * sums[r + 2] - sums[i + 1] - (r - i + 1) * (sums[i + 1] - sums[l])


```



写成公式的形式：
$$
\begin{aligned}
\sum_{r = i + 1}^{R + 1}\sum_{l = L}^{i}sum[r] - sum[l]
&=(i - L + 1)\sum_{r = i + 1}^{R + 1}sum[r] - (R - i + 1)\sum_{l = L}^{i}sum[l]
\\&=(i - L + 1)(sums[R + 2] - sums[i + 1]) - (R - i + 1)(sums[i + 1] - sums[L])
\end{aligned}
$$







[2289. 使数组按非递减顺序排列](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/)











### 单调栈总结：

1. 前缀和使用**[l, r] => sum[r + 1] - sum[l]**来进行计算

2. 单调栈中求**[l, r]**，不求前一个和后一个，方便进行计数，也就是(r - i + 1) 与 (i - l + 1)这种。
3. 单调栈**，一般是一个求等于，一个求不等。那么就可以直接使用常数优化了**。
   - 初始值必须赋值。
   - <= 的时候弹出。
4. 也就是说都使用**闭区间**， 常数优化和这个不关联。

