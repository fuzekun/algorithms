# 马拉车/Manacher算法



回文字符串的通俗定义是：如果一个字符串正着读或反着读都一样，那么称这个字符串为回文字符串。**Manacher的作用就是在O(N)的时间复杂度下求出以每个位置为回文中心的回文半径**





## 讲解

### 1. 一些定义

![image-20220416084213882](D:\blgs\source\imgs\image-20220416084213882.png)



### 2. 分类讨论

![image-20220416084308068](D:\blgs\source\imgs\image-20220416084308068.png)

![image-20220416084653931](D:\blgs\source\imgs\image-20220416084653931.png)



![image-20220416084832927](D:\blgs\source\imgs\image-20220416084832927.png)



### 3. 代码实现



![image-20220414094835510](D:\blgs\source\imgs\image-20220414094835510.png)

![image-20220414094924672](D:\blgs\source\imgs\image-20220414094924672.png)





1. 把情况2）3）融合到了情况1）和4）中去，如果不进行扩列。直接一次while循环就退出了。
   - 第一种最小是1
   - 第二种和第三种是 pArr[2 * C - i] 和R - i
   - 第四种最小是R - i
1. 对称点如下

![image-20220416084911409](D:\blgs\source\imgs\image-20220416084911409.png)

3. 另外R代表的是最右点 **+ 1**；
   - 因为 s[i + pArr[i]]不等于 s[i - pArr[i]]
4. 最后答案需要 - 1；



## 例题





[最长回文](https://ac.nowcoder.com/acm/problem/14894)



两个回文串的最长最长回文，满足A[l1...r1] == B[r1...r2]。注意l2 == r1。

- 如果原串有就直接使用原串的回文，如果原串没有在用B的或者A的字符。
- 应该错开一个字符进行匹配。

abcd		abc

cdba		cba



#a#b#c#

​	 #c#b#a#

​	#a#b#c#d#

#c#d#b#a#



朴素的思想：如果匹配失败了，就应该让i-s和下面的某一个字符进行匹配。

应该和哪个进行匹配呢？

朴素想法：i + s进行匹配。

但是由于是l1和r2重合。所以让下面的偏移一个字符，就是对应的**[l1, r1]和[r1 + 1, r2]**这种，加上了#号就偏移两个字符。

​	 #N#S#Z#Q#Z#F#C#

#C#F#Z#Q#Z#S#N#





就是这样：

减去2相当于平移了两个位置。就对应着B向右平移了一个位置。

正常来说 - 1就行了，但是加上了#就需要减2才能进行匹配。



A[2] 匹配 B[0]。			A[2]匹配B[1]。

A[3] 匹配 B[1]这种。	A[3]匹配B{2]这种。



