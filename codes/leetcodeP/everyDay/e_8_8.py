"""

8.8每日一题

知识点：
1. 字符串
2. 二进制
3. 前缀
4. 子序列
5. 字典序


特殊：
1. 前缀中1的个数大于0的个数
2. 连续子序列


类型：
贪心 + 找规律

特殊子串
10
1100, 1010
111000, 110100, 101010
111000, 101010 -> 不用交换
10 -> 最小的可以交换的子串
也就是尽量的让10子串在后面出现。因为最差的结果就是全部都是10子串。

1100111000
1110001100

所以贪心策略就是把左边的10尽量向右放
1010101100

11011011100000 -> 11101110000100 -> 11111000100100

使用栈进行模拟
性质：一定是以1开头，以0结尾，类似于括号

1
- 10， 1
-- 10 111000 -> 11100010
- 10, 1111000100 -> 111100010010
11111000100100


本题目有了思路，但是求解起来还是很麻烦。
原因是：不知道怎么使用代码描述这个过程，以及对于过程的处理不符合代码。

正确的处理过程：
1. 对于每一个特殊字符串，每次去掉1和0，然后变成子问题。
2. 处理好的子串进行排序之后合并，最后加上


11011011100000
- 101101110000
-- 10, 1 10111000 0
---
"""

class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        if len(s) <= 2:
            return s

        cnt = left = 0
        sub = list()
        for i, ch in enumerate(s) :
            if ch == '1':
                cnt += 1
            else :
                cnt -= 1
                if cnt == 0:
                    sub.append('1' + self.makeLargestSpecial(s[left + 1 : i]) + '0')
                    left = i + 1
        sub = sorted(sub, reverse=True)
        return "".join(sub)



if __name__ == '__main__':
    s = Solution()
    ans = s.makeLargestSpecial("11011011100000")
    print(ans)